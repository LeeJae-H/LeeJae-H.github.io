---
layout: post
title: (Spring) - 스프링이 제공하는 ServletContainerInitializer (+WebApplicationContext) (+ContextLoaderListener)
date: 2024-05-21
categories: [spring]
---
<center><img src="https://github.com/LeeJae-H/LeeJae-H.github.io/assets/122717063/af7f09d3-6061-4fc2-8124-73fdde2cb87c" width="700" height="330"></center>
> - 스프링은 ServletContainerInitializer 인터페이스를 구현한 클래스로 SpringServletContainerInitializer를 제공하며, <span style="color:red">개발자가 실제 구현해야 하는 것은 WebApplicationInitializer</span>이다.  
    -> [ServletContainerInitializer를 사용한 서블릿 컨테이너 초기화](https://leejae-h.github.io/posts/55/)

### SpringServletContainerInitializer
```java
@HandlesTypes({WebApplicationInitializer.class})
public class SpringServletContainerInitializer implements ServletContainerInitializer 
    {
        public void onStartup(@Nullable Set<Class<?>> webAppInitializerClasses, 
                              ServletContext servletContext) 
                              throws ServletException 
        {
            ...
            WebApplicationInitializer initializer = (WebApplicationInitializer) var4.next();
            initializer.onStartup(servletContext);
            ...
        }
    }
```
- SpringServletContainerInitializer는 WebApplicationInitializer 구현체를 인스턴스화하고 ServletContext를 위임하는 역할을 한다. 즉, ServletContext를 초기화하는 실제 작업을 WebApplicationInitializer 구현체가 수행한다.

- **동작 매커니즘**
    - spring-web 모듈 JAR가 클래스패스에 있으면, SpringServletContainerInitializer는 서블릿 컨테이너가 시작될 때 로드되고 인스턴스화되며 onStartup 메소드가 호출된다.
        - JAR 서비스 API의 ServiceLoader.load(Class) 메소드가 spring-web 모듈의 /META-INF/services/jakarta.servlet.ServletContainerInitializer 파일을 감지함으로써 발생하는 것이다.    
    - onStartup 메소드는 WebApplicationInitializer 구현체들을 찾아서 초기화하는 역할을 한다.
    - WebApplicationInitializer 구현체가 없는 경우
        - 만약 클래스패스에서 WebApplicationInitializer 구현체를 찾을 수 없다면, 이 메서드는 아무 작업도 수행하지 않는다. 이 경우, INFO 레벨의 로그 메시지를 남겨서 ServletContainerInitializer가 호출되었지만 WebApplicationInitializer 구현체를 찾지 못했음을 사용자에게 알린다.
    - WebApplicationInitializer 구현체가 있는 경우
        - 하나 이상의 WebApplicationInitializer 타입이 감지되면, 이 구현체들은 인스턴스화된다. (만약 @Order 어노테이션이 존재하거나 Ordered 인터페이스를 구현한 경우, 이 구현체들은 정렬된다.) 그런 다음, 각 인스턴스의 WebApplicationInitializer.onStartup(ServletContext) 메서드가 호출된다. 이 과정에서 ServletContext가 각 인스턴스에 위임되어 각 인스턴스가 Spring의 DispatcherServlet, ContextLoaderListener 등의 서블릿, 리스너 또는 필터와 같은 서블릿 API 기능을 등록하고 구성할 수 있도록 한다. 
            - ServletContext 객체의 생성은 서블릿 컨테이너가 하고, 초기화 작업은 WebApplcationInitializer가 한다.
            - 즉, 서블릿 컨테이너가 생성한 ServletContext를 SpringServletContainerInitializer가 받아서, 이를 사용자 정의 WebApplicationInitializer 구현체들에게 전달(delegating)한다는 의미이다.

- 요약하자면, 서블릿 컨테이너를 실행하면 서블릿 컨테이너를 초기화하는데, 이 과정에서 핵심은 ServletContext 객체를 초기화하는 것이다. 이 ServletContext 객체를 초기화하는 방법은 web.xml 방식과 SpringServletContainerInitializer 방식이다.


### WebApplicationInitializer







---

### DispatcherServlet 등록 및 매핑
- DispatcherServlet은 다른 서블릿과 마찬가지로 등록 및 매핑되어야 한다.
    - 서블릿 등록 및 매핑 방식 : "블로그"
    - DispatcherServlet의 등록 및 매핑 방식은 위의 글에서와 같이  



- ApplicationContext 를 스프링 컨테이너라 한다.
    - ApplicationContext 는 인터페이스이다.
    - 스프링 컨테이너는 XML을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있다.
    - ApplicationContext applicationContext =
new AnnotationConfigApplicationContext(AppConfig.class); 처럼 AppConfig 를 사용했던 방식이 애노테이션 기반의 자바 설정 클래스로 스프링 컨테이너를 만든 것이다.


### DispatcherServlet의 등록 방식
1. web.xml 작성

2. WebApplicationInitializer 인터페이스를 직접 구현(implements)

3. WebApplicationInitializer 인터페이스를 구현한 추상 클래스인 AbstractAnnotationConfigDispatcherServletInitializer를 구현(extends)


- 클라이언트로부터 어떠한 요청이 오면 Tomcat(톰캣)과 같은 서블릿 컨테이너가 요청을 받게 됩니다. 그리고 이 모든 요청을 프론트 컨트롤러인 디스패처 서블릿이 가장 먼저 받게 됩니다. 그러면 디스패처 서블릿은 공통적인 작업을 먼저 처리한 후에 해당 요청을 처리해야 하는 컨트롤러를 찾아서 작업을 위임한다.


- DispatcherServlet은 서블릿 컨테이너에 등록되어 있으며, 클라이언트의 모든 요청을 받아들입니다. 클라이언트로부터의 요청이 들어오면 DispatcherServlet이 그 요청을 받아들이고, 해당 요청을 처리할 컨트롤러에게 전달하는 역할을 한다.


<스프링을 사용안할 경우>
- 어떤 요청이 들어오면 서블릿 컨테이너는 요청의 url에 맞는 서블릿을 web.xml이나 어노테이션을 찾아서 서블릿을 찾음.
<스프링을 사용할 경우>
- 어떤 요청이 들어오면 일단 디스패처 서블릿이 모든 요청을 받고, 디스패처 서블릿이 어노테이션을 찾아서 요청의 url에 맞는 컨트롤러를 찾음.


<스프링을 사용하지 않는 경우> 
요청이 왔을 때 해당 서블릿이 생성이 안돼있으면 서블릿 컨테이너가 서블릿을 생성하고 init()을 수행한 후 service() 수행.
<스프링을 사용하는 경우>
요청이 왔을 때 디스패처 서블릿은 서버가 실행될때 이미 생성되어있어 생성과 init()을 할 필요가 없음. 컨트롤러 인스턴스는 싱글톤 빈으로 관리되며, 기본적으로 스프링 컨테이너가 시작될 때 미리 생성됨.
    - 컨트롤러의 인스턴스가 생성되는 시점
        1. 미리 생성
            - @Controller 어노테이션이 붙은 클래스는 스프링 컨테이너가 초기화될 때 자동으로 스캔되어 빈으로 등록됩니다. 따라서 서버가 시작될 때 스프링 컨테이너가 해당 컨트롤러 클래스를 스캔하고 인스턴스를 생성합니다.
            - XML 또는 자바 설정 파일에 명시적으로 빈을 등록한 경우에도 스프링 컨테이너가 시작될 때 해당 빈이 인스턴스화됩니다.
        2. 요청이 들어올때 마다 생성
            - 요청이 들어올 때마다 컨트롤러를 생성하는 방법도 있습니다. 이 경우는 프로토타입(scope="prototype") 범위로 컨트롤러를 정의하여 요청이 들어올 때마다 새로운 인스턴스를 생성합니다. 하지만 이 방법은 매번 요청이 들어올 때마다 컨트롤러를 생성하므로 성능상의 이슈가 있을 수 있습니다.
    - 스프링 컨테이너 생성 시점
        - 스프링 컨테이너는 웹 애플리케이션이 서버에 배포되고 서버가 시작될 때 초기화됩니다. 이때 서블릿 컨테이너가 시작되고 서블릿이 로딩되고 초기화되는 과정에서 스프링 컨테이너도 함께 초기화됩니다.
        - 스프링 컨테이너의 초기화는 대개 다음과 같은 시점에서 이루어집니다.
            1. 웹 애플리케이션 컨텍스트의 로딩 시점: 웹 애플리케이션 컨텍스트는 스프링의 핵심이 되는 객체로서, 서블릿 컨테이너가 웹 애플리케이션을 로딩할 때 생성됩니다. 따라서 스프링 컨테이너는 웹 애플리케이션 컨텍스트의 로딩 시점에 초기화됩니다.
            2. ContextLoaderListener 또는 FrameworkServlet의 초기화: 스프링 웹 애플리케이션에서는 ContextLoaderListener 또는 FrameworkServlet이 서블릿 컨테이너에 의해 초기화됩니다. 이 때 ContextLoaderListener는 root 웹 애플리케이션 컨텍스트를 초기화하고, FrameworkServlet은 서블릿 웹 애플리케이션 컨텍스트를 초기화합니다.
            3. @ServletInitializer 또는 web.xml 파일의 설정: 스프링 부트 애플리케이션에서는 ServletInitializer 클래스를 사용하여 스프링 컨테이너를 초기화할 수 있습니다. 또한 전통적인 웹 애플리케이션에서는 web.xml 파일의 설정을 통해 스프링 컨테이너를 초기화할 수도 있습니다.
- 초기화된 스프링 컨테이너는 애플리케이션의 빈들을 관리하고, 요청에 따라 적절한 빈을 찾아서 의존성 주입 등을 수행하여 요청을 처리하는 데 사용됩니다.






---
참고 자료  
https://tomcat.apache.org/tomcat-7.0-doc/servletapi/javax/servlet/ServletContainerInitializer.html  
https://tomcat.apache.org/tomcat-8.0-doc/servletapi/javax/servlet/ServletContext.html  
https://tomcat.apache.org/tomcat-7.0-doc/servletapi/javax/servlet/ServletRegistration.Dynamic.html  
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/SpringServletContainerInitializer.html  
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/WebApplicationInitializer.html  
https://kimcoder.tistory.com/511  
https://recordsoflife.tistory.com/490  
https://escapefromcoding.tistory.com/174  
https://offbyone.tistory.com/215  
https://nhs0912.tistory.com/81  
https://blog.naver.com/kitepc/221314687808  
https://velog.io/@rolroralra/Chapter0.-Servlet-컨테이너-Spring-컨테이너  
